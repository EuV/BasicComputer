#summary Общее видение новой реализации

= Примерная структура классов =

1. Корневой класс имеет:
 * конструктор(width, input), регистрирующийся в input-ах через addListener()
 * addListener()
 * removeListener()
 * метод execute() вызываемый при срабатывании листенера
 * поля value, width и mask
 * get()
 * get(bitno)
 * get(startbit, bitno)
 * set()
 * getwidth()
 * setbit()
 * invertbit()

2. расшырение корня - память
 * конструктору еще указываем его регистр адреса, из которого узнаём объём памяти
 * по execute записывает в value значение ячейки по адресу из своего РА

3. расшырение корня - шЫна
 * конструктор имеет много input-ов, но на них мы не подписываемся.
 * при execute() делаем input1 | input2 | input3
 * override-ит addListener, который НИЧЕГО не делает

4. расшырение корневого - вентиль
 * конструктору указываем datainput и controlinput. для inputdata также указываем стартовый бит и количество бит, для controlinput - номер управляющего бита. регистрация listener-ом только для controlinput
 * execute проверяет установленность требуемого бита и делает записывает значение в value и дёргает слушателей только если он установлен.

5. расшырения вентиля - вентиль-не, вентиль+1, вентиль проверяющий на равенство 0, вентили имеющие по два datainput для сдвигов, сложения, сложения+1, логического умножения, ...

6. расшЫрение корневого - инвертор
 * конструктору указываем номер бита, который инвертировать

7. расшЫрение корня - дешЫфратор
 * конструктору указываем input и стартовый/количество бит. на выходе формируем дешЫфрованный сигнал (0->0x01, 1->0x02, ..., 7-> 0x80, ...)

8. расшЫрение корна - схема сравнения
 * input - шЫна собирающая данные с ВВ0-15, подписываемся на срабатывание УМК

= Примерная прикидка логики работы =
Принудительно дёргается execute памяти микрокоманд
Память дёргает слушателей:
 * РМК, который тупо записывает в себя значение команды
 * вентиль похожый на ВР0
 * инвертор, инвертирующий старшЫй бит и запускающий вентиль похожЫй на ВР1
ВР0 дёргает ВР00 (для ОМК0) и через инвертор ВР01 (для ОМК1), которые дёргают в нужном порядке свои дешыфраторы, которые дёргают вентили, от которых кружыццо БЭВМ, и всё зашуршало

Баги:
 # для УМК надо внимательно подумать над его допвентилем и тем, кого ему слушать для передачи из БР на ВВ0-15
 # Для СчМК придёцца звать отдельно указание input-а из псевдобаса из-за цЫкличности структуры
 # На псевдобас будут повешены три вентиля: вентиль+1, заводящийся от любой ОМК и вентиль-перехода + вентиль+1-через-инвертор-если-перехода-нет

Фича: Вроде не нужно чистить состояние вентилей и прочего в конце такта

= Пакеты =
 * bcomp - сама БЭВМ
 * bcomp.cpu - проц с памятью и шынами нужными для ВВ
 * bcomp.io - устройство ВВ, конструктору грим откуда чтим, куда пишем (may be NULL)