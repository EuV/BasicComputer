#summary Ассемблер БЭВМ

= Ассемблер [bcomp БЭВМ] =

<wiki:toc max_depth="2"/>

= Синтаксис =
|| Адресная команда с прямой адресацией || `[метка:] МНЕМОНИКА АРГУМЕНТ` || `MOV R` ||
|| Адресная команда с косвенной адресацией || `[метка:] МНЕМОНИКА (АРГУМЕНТ)` || `ADD (K)` ||
|| Безадресная команда || `[метка:] МНЕМОНИКА` || `BEGIN: CLA` ||
|| Команда ввода-вывода || `[метка:] МНЕМОНИКА АДРЕСВУ` || `OUT 3` ||
|| Директива ORG || `ORG адрес` || `ORG 10` ||
|| Директива WORD || `[метка:] WORD` || `X: WORD` ||
|| Константа по значению || `[метка:] ЗНАЧЕНИЕ` || `N: -6` ||
|| Константа с адресом метки || `[метка:] МЕТКА` || `K: X` ||

= Директивы =
 # ORG address - указывает компилятору, что следующее значение необходимо располагать по указанному адресу. Идентична пультовой команде "Ввод адреса". При использовании данной директивы следует проявлять внимание, так как директива не проверяет занятость указанной ячейки, и возможно возникновение перекрытий частей программы. Обычно данную директивую достаточно использовать один раз в начале программы.
 # WORD - указывает компилятору, что необходимо зарезервировать очередную ячейку, но не записывать в неё значение. Если метка указывает на данную директиву, то БЭВМ считает её исходным данным и, например, в [cli консольной версии БЭВМ] будет запрашивать его значение при использовании команды arguments.

= Метки =
Метки используются как аргументы для адресных команд. В имени метки могут использоваться любые символы, однако, в связи с особенностями обработки констант, не рекомендуется использовать имена меток, которые могут быть восприняты как шестнадцатиричное число.

= Специальные метки =
 # BEGIN - указывает компилятору на первую выполняемую команду программы. Должна быть указана в любой программе.
 # R - указывает на ячейку, в которой будет располагаться результат. После успешной компиляции, если в программе была обнаружена метка R, [cli консольная версия БЭВМ] выведет адрес соответствующей метке ячейки памяти. Аргументом программы не считается, и её значение не запрашивается при вводе исходных данных.
 # _любоеимя - метки, имена которых начинаяются с символа "_", считаются внутренними переменными программы, и их значения также не запрашиваются при вводе исходных данных.

= Примеры использования =
== Задача ==
В массиве из 6-ти элементов посчитать количество неотрицательных элементов.

== Решение 1. Старый стиль ==
{{{
ORG	00F
	0020
BEGIN:	F200
	480F
	A017
	F200
	401B
	F800
	301B
	001A
	C010
	F000

	FFFA
R:	0000

ORG	020
	0001
	FFFF
	0002
	FFFE
	0003
	FFFD
}}}
Преимущества:
 # Работает.
 # Ввод программы максимально приближен к обычной работе с [bcomp БЭВМ].
Недостатки:
 # Собственно возможности ассемблера не используются.
 # Для запуска программы с другими исходными данными необходимо полностью делать это вручную.

== Решение 2. Студенческое ==
{{{
ORG	00F
K:	X1

BEGIN:	CLA
	ADD	(K)
	BMI	SKIP
	CLA
	ADD	R
	INC
	MOV	R
SKIP:	ISZ	N
	BR	BEGIN
	HLT

N:	-6
R:	WORD

ORG	020
X1:	WORD
X2:	WORD
X3:	WORD
X4:	WORD
X5:	WORD
X6:	WORD
}}}
Преимущества:
 # Тоже работает.
 # При использовании [cli консольного эмулятора БЭВМ] команда arguments запросит значение только для элементов массива.
Недостатки:
 # Из поля зрения пропадают два исходных данных K и N.
 # При вводе аргументов значения K и N не будут обновлены, и, если программа будет запущена повторно, то работать она будет некорректно.

== Решение 2. Правильное ==
{{{
ORG	00F
K:	WORD

BEGIN:	CLA
	ADD	(K)
	BMI	SKIP
	CLA
	ADD	R
	INC
	MOV	R
SKIP:	ISZ	N
	BR	BEGIN
	HLT

N:	WORD
R:	WORD

ORG	020
X1:	WORD
X2:	WORD
X3:	WORD
X4:	WORD
X5:	WORD
X6:	WORD
}}}
Преимущества:
 # Видны все исходные данные, используемые программой.
Недостатки:
 # При использовании других значений K и N БЭВМ всё равно не станет вводить нужное количество элементов массива с изменившегося адреса.
 # Перед каждым запуском потребуется вводить значения K и N. Но, при этом, возможен следующий диалог:
{{{
arguments
K: X1
N: -6
X1: 1
X2: -1
X3: 2
X4: -2
X5: 3
X6: -3
}}}
