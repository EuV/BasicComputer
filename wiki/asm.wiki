#summary Ассемблер БЭВМ

= Ассемблер [bcomp БЭВМ] =

<wiki:toc max_depth="3"/>

= Синтаксис =
|| Адресная команда с прямой адресацией || `[метка:] МНЕМОНИКА АРГУМЕНТ` || `MOV R` ||
|| Адресная команда с косвенной адресацией || `[метка:] МНЕМОНИКА (АРГУМЕНТ)` || `ADD (K)` ||
|| Безадресная команда || `[метка:] МНЕМОНИКА` || `BEGIN: CLA` ||
|| Команда ввода-вывода || `[метка:] МНЕМОНИКА АДРЕСВУ` || `OUT 3` ||
|| Директива ORG || `ORG адрес` || `ORG 10` ||
|| Директива WORD || `[метка:] WORD` || `X: WORD` ||
|| Константа по значению || `[метка:] ЗНАЧЕНИЕ` || `N: -6` ||
|| Константа с адресом метки || `[метка:] МЕТКА` || `K: X` ||

= Директивы =
 # ORG address - указывает компилятору, что следующее значение необходимо располагать по указанному адресу. Идентична пультовой команде "Ввод адреса". При использовании данной директивы следует проявлять внимание, так как директива не проверяет занятость указанной ячейки, и возможно возникновение перекрытий частей программы. Обычно данную директивую достаточно использовать один раз в начале программы.
 # WORD - указывает компилятору, что необходимо зарезервировать очередную ячейку, но не записывать в неё значение. Если метка указывает на данную директиву, то БЭВМ считает её исходным данным и, например, в [cli консольной версии БЭВМ] будет запрашивать его значение при использовании команды arguments.

= Метки =
Метки используются как аргументы для адресных команд. В имени метки могут использоваться любые символы, однако, в связи с особенностями обработки констант, не рекомендуется использовать имена меток, которые могут быть восприняты как шестнадцатиричное число.

= Специальные метки =
 # BEGIN - указывает компилятору на первую выполняемую команду программы. Должна быть указана в любой программе.
 # R - указывает на ячейку, в которой будет располагаться результат. После успешной компиляции, если в программе была обнаружена метка R, [cli консольная версия БЭВМ] выведет адрес соответствующей метке ячейки памяти. Аргументом программы не считается, и её значение не запрашивается при вводе исходных данных.
 # `_`любоеимя - метки, имена которых начинаяются с символа "`_`", считаются внутренними переменными программы, и их значения также не запрашиваются при вводе исходных данных.

= Комментарии =
Любой текст в строке после символов ; и # считается комментарием.

= Примеры использования =
== Задача 1 ==
Сложить два числа.
{{{
ORG	010
BEGIN:	CLA
	ADD	X
	ADD	Y
	MOV	R
	HLT

ORG	018
R:	WORD
X:	DEAD
Y:	BEEF
}}}

== Задача 2 ==
В массиве из 6-ти элементов посчитать количество неотрицательных элементов.

=== Решение 1. Старый стиль ===
{{{
ORG	00F
	0020
BEGIN:	F200
	480F
	A017
	F200
	401B
	F800
	301B
	001A
	C010
	F000

	FFFA
R:	0000

ORG	020
	0001
	FFFF
	0002
	FFFE
	0003
	FFFD
}}}
Преимущества:
 # Работает.
 # Ввод программы максимально приближен к обычной работе с [bcomp БЭВМ].
Недостатки:
 # Собственно возможности ассемблера не используются.
 # Для запуска программы с другими исходными данными необходимо полностью делать это вручную.

=== Решение 2. Студенческое ===
{{{
ORG	00F
K:	X1

BEGIN:	CLA
	ADD	(K)
	BMI	SKIP
	CLA
	ADD	R
	INC
	MOV	R
SKIP:	ISZ	N
	BR	BEGIN
	HLT

N:	-6
R:	WORD

ORG	020
X1:	WORD
X2:	WORD
X3:	WORD
X4:	WORD
X5:	WORD
X6:	WORD
}}}
Преимущества:
 # Тоже работает.
 # При использовании [cli консольного эмулятора БЭВМ] команда arguments запросит значение только для элементов массива.
Недостатки:
 # Из поля зрения пропадают два исходных данных K и N.
 # При вводе аргументов значения K и N не будут обновлены, и, если программа будет запущена повторно, то работать она будет некорректно.

=== Решение 2. Правильное ===
{{{
ORG	00F
K:	WORD		; Адрес первого элемента массива

BEGIN:	CLA
	ADD	(K)
	BMI	SKIP
	CLA
	ADD	R
	INC
	MOV	R
SKIP:	ISZ	N
	BR	BEGIN
	HLT

N:	WORD		; Количество элементов массива
R:	WORD		; Результат

ORG	020		; Элементы массива
X1:	WORD
X2:	WORD
X3:	WORD
X4:	WORD
X5:	WORD
X6:	WORD
}}}
Преимущества:
 # Видны все исходные данные, используемые программой.
Недостатки:
 # При использовании других значений K и N БЭВМ всё равно не станет вводить нужное количество элементов массива с изменившегося адреса.
 # Перед каждым запуском потребуется вводить значения K и N. Но, при этом, возможен следующий диалог:
{{{
arguments
K: X1
N: -6
X1: 1
X2: -1
X3: 2
X4: -2
X5: 3
X6: -3
}}}

== Задача 3 ==
 # Основная программа должна в цикле увеличивать содержимое аккумулятора.
 # При запросе от ВУ1 выводить накопленное значение в РД ВУ1.
 # При запросе от ВУ2 в аккумулятор записывать значение из РД ВУ2.
 # При запросе от ВУ3 обменивать местами накопленное в аккумуляторе значение и содержимое РД ВУ3.
 # Обмен с ВУ осуществлять в режиме прерывания.
{{{
ORG	000
RET:	WORD
	BR	INT

ORG	010
BEGIN:	EI
	CLA
LOOP:	INC
	BR LOOP

ORG	020
INT:	TSF	1
	BR IO2
	OUT	1
	CLF	1
	BR	END
IO2:	TSF 2
	BR	IO3
	IN	2
	BR	END
IO3:	MOV	TMP1
	CLA
	IN	3
	CLF	2
	MOV	TMP2
	CLA
	ADD	TMP1
	OUT	3
	CLF	3
	CLA
	ADD	TMP2
END:	EI
	BR	(RET)
TMP1:	WORD
TMP2:	WORD
}}}
